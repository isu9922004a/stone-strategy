import React, { useState, useEffect, useCallback } from 'react';

/**
 * PWA é…ç½®èˆ‡ Service Worker è¨»å†Š
 * åœ¨ç”Ÿç”¢ç’°å¢ƒä¸­ï¼Œé€™æœƒå…è¨±æ‡‰ç”¨ç¨‹å¼åœ¨é›¢ç·šæ™‚é‹è¡Œ
 */
const registerServiceWorker = () => {
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      const swUrl = `data:text/javascript;base64,${btoa(`
        const CACHE_NAME = 'mahjong-pwa-v1';
        const urlsToCache = ['/', '/index.html'];
        self.addEventListener('install', event => {
          event.waitUntil(caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache)));
        });
        self.addEventListener('fetch', event => {
          event.respondWith(caches.match(event.request).then(response => response || fetch(event.request)));
        });
      `)}`;
      navigator.serviceWorker.register(swUrl).catch(err => console.log('SW registration failed:', err));
    });
  }
};

// ==========================================
// éŠæˆ²è¼”åŠ©å‡½å¼ã€å¸¸æ•¸èˆ‡å°è©±åº«
// ==========================================

const TILE_MAP = {
    'W1': 'ğŸ€‡', 'W2': 'ğŸ€ˆ', 'W3': 'ğŸ€‰', 'W4': 'ğŸ€Š', 'W5': 'ğŸ€‹', 'W6': 'ğŸ€Œ', 'W7': 'ğŸ€', 'W8': 'ğŸ€', 'W9': 'ğŸ€', 
    'S1': 'ğŸ€', 'S2': 'ğŸ€‘', 'S3': 'ğŸ€’', 'S4': 'ğŸ€“', 'S5': 'ğŸ€”', 'S6': 'ğŸ€•', 'S7': 'ğŸ€–', 'S8': 'ğŸ€—', 'S9': 'ğŸ€˜', 
    'T1': 'ğŸ€™', 'T2': 'ğŸ€š', 'T3': 'ğŸ€›', 'T4': 'ğŸ€œ', 'T5': 'ğŸ€', 'T6': 'ğŸ€', 'T7': 'ğŸ€Ÿ', 'T8': 'ğŸ€ ', 'T9': 'ğŸ€¡', 
    'F1': 'ğŸ€€', 'F2': 'ğŸ€', 'F3': 'ğŸ€‚', 'F4': 'ğŸ€ƒ', 
    'J1': 'ğŸ€„', 'J2': 'ğŸ€…', 'J3': 'ğŸ€†', 
};

const SUIT_ORDER = { 'W': 1, 'T': 2, 'S': 3, 'F': 4, 'J': 5 };

const CHARACTERS = [
    { name: 'æ†²å“¥', avatar: 'ğŸ¤µğŸ¼', style: 'text-orange-400', 
      quotes: { 
          draw: ["å˜¿å˜¿ï¼è¦‹é¬¼å•¦ï¼", "é€™ç‰ŒçœŸæ˜¯å¤ªéŠ·é­‚äº†ï¼", "å“å‘€ï¼Œå·®ä¸€é»ï¼"], 
          discard: ["éš¨ä¾¿æ‰“å•¦ï¼", "é€™å¼µæ²’ç”¨äº†", "å«‚å­è³£é¤ƒå­ï¼"], 
          win: ["æˆ‘æ˜¯Local Kingï¼è´å•¦ï¼", "å“‡å“ˆå“ˆå“ˆï¼çµ¦éŒ¢çµ¦éŒ¢ï¼"],
          lose: ["å¤ªçäº†å§ï¼", "ä»Šå¤©æ‰‹æ°£çœŸèƒŒï¼"]
      }
    },
    { name: 'ä¹ƒå“¥', avatar: 'ğŸ‘¨ğŸ»â€ğŸ’¼', style: 'text-blue-400', 
      quotes: { 
          draw: ["ä¸è¦åµæˆ‘æ€è€ƒï¼", "ç‰Œæ€éº¼é€™éº¼çˆ›ï¼", "å¿«é»å•¦ï¼"], 
          discard: ["ä½ æ‡‚ä¸æ‡‚è¦çŸ©å•Šï¼", "é€™å¼µä½ æ•¢è¦ï¼Ÿ", "éš¨ä¾¿å‡ºå•¦ï¼"], 
          win: ["çœ‹å§ï¼é€™å°±æ˜¯å¯¦åŠ›ï¼", "æœä¸æœæ°£å•Šï¼"],
          lose: ["ä¸éŒ„äº†ï¼ä¸éŒ„äº†ï¼", "è„¾æ°£éƒ½ä¸Šä¾†äº†ï¼", "é€™ç™¼ç‰Œå“¡æœ‰å•é¡Œï¼"]
      }
    },
    { name: 'ç“œå“¥', avatar: 'ğŸ§‘ğŸ»â€ğŸ’¼', style: 'text-green-400', 
      quotes: { 
          draw: ["ä¸»å§”åŠ ç¢¼ï¼", "ç¹¼çºŒé€å¹¸ç¦ï¼", "é€™å¼µæ°´å–”ï¼"], 
          discard: ["ä¸‹é¢ä¸€ä½ï½", "é€™å¼µçµ¦ä½ å•¦ï¼", "éš¨ä¾¿ä¸Ÿéš¨ä¾¿ä¸­ï¼"], 
          win: ["èƒ¡å•¦ï¼æ­å–œç™¼è²¡ï¼", "å¤ªçˆ½å•¦ï¼çé‡‘æ‹¿ä¾†ï¼"],
          lose: ["å“å‘€ï¼Œå¯æƒœå•Šï¼", "ä¸‹æ¬¡å†è¨å›ä¾†ï¼"]
      }
    },
    { name: 'è±¬å¤§å“¥', avatar: 'ğŸ§”ğŸ»', style: 'text-yellow-400', 
      quotes: { 
          draw: ["æ—åŒ—è·Ÿä½ æ‹¼äº†ï¼", "é€™ä»€éº¼é¬¼ç‰Œï¼", "å¥½ç‰Œå¿«ä¾†ï¼"], 
          discard: ["å†·æ¶¼å¡å¥½ï¼", "å‡ºé€™ä»€éº¼ç‰Œå•¦ï¼", "å»ä½ çš„ï¼"], 
          win: ["å“ˆå“ˆå“ˆï¼è´åˆ°è„«è¤²ï¼", "å«æˆ‘è³­ç¥å•¦ï¼"],
          lose: ["æš—é™°ç¾Šå’§ï¼", "è¼¸åˆ°è¦è·‘è·¯äº†ï¼"]
      }
    }
];

function generateDeck() {
    let deck = [];
    Object.keys(TILE_MAP).forEach(id => {
        for (let i = 0; i < 4; i++) {
            deck.push({ id, uniqueId: `${id}-${i}`, symbol: TILE_MAP[id] });
        }
    });
    for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
    }
    return deck;
}

function sortHand(hand) {
    return [...hand].sort((a, b) => {
        const typeA = a.id[0], typeB = b.id[0];
        if (SUIT_ORDER[typeA] !== SUIT_ORDER[typeB]) {
            return SUIT_ORDER[typeA] - SUIT_ORDER[typeB];
        }
        return parseInt(a.id[1]) - parseInt(b.id[1]);
    });
}

function checkHu(tiles) {
    if (tiles.length % 3 !== 2) return false;
    let counts = {};
    for (let t of tiles) counts[t.id] = (counts[t.id] || 0) + 1;
    let uniqueTiles = Object.keys(counts);
    for (let pair of uniqueTiles) {
        if (counts[pair] >= 2) {
            let tempCounts = { ...counts };
            tempCounts[pair] -= 2;
            if (checkMelds(tempCounts, tiles.length - 2)) return true;
        }
    }
    return false;
}

function checkMelds(counts, remaining) {
    if (remaining === 0) return true;
    let firstTile = Object.keys(counts).find(k => counts[k] > 0);
    if (!firstTile) return true;
    if (counts[firstTile] >= 3) {
        counts[firstTile] -= 3;
        if (checkMelds(counts, remaining - 3)) {
            counts[firstTile] += 3; 
            return true;
        }
        counts[firstTile] += 3;
    }
    let type = firstTile[0]; 
    let num = parseInt(firstTile[1]);
    if (type !== 'F' && type !== 'J' && num <= 7) {
        let t2 = type + (num + 1);
        let t3 = type + (num + 2);
        if (counts[t2] > 0 && counts[t3] > 0) {
            counts[firstTile]--; counts[t2]--; counts[t3]--;
            if (checkMelds(counts, remaining - 3)) {
                counts[firstTile]++; counts[t2]++; counts[t3]++;
                return true;
            }
            counts[firstTile]++; counts[t2]++; counts[t3]++;
        }
    }
    return false;
}

// ==========================================
// é¡¯ç¤ºå…ƒä»¶
// ==========================================

const MahjongTile = ({ tile, isSelected, onClick, className = '', isFaceDown = false, isDiscard = false }) => {
    if (isFaceDown) {
        return (
            <div className={`w-8 h-12 sm:w-10 sm:h-14 rounded bg-green-700 border-2 border-green-800 shadow-[2px_2px_0px_#14532d] flex-shrink-0 ${className}`}></div>
        );
    }
    const isRed = tile.id.startsWith('W') || tile.id === 'J1';
    const isGreen = tile.id.startsWith('S') || tile.id === 'J2';

    return (
        <div onClick={onClick} 
             className={`relative bg-[#f4f4f0] rounded border border-gray-300 flex items-center justify-center flex-shrink-0 transition-transform select-none
             ${onClick ? 'cursor-pointer hover:-translate-y-1' : ''} 
             ${isSelected ? '-translate-y-4 shadow-xl ring-2 ring-yellow-400' : 'shadow-[1px_3px_0px_#9ca3af]'} 
             ${isDiscard ? 'w-8 h-10 sm:w-10 sm:h-12 text-2xl sm:text-3xl' : 'w-10 h-14 sm:w-12 sm:h-16 text-4xl sm:text-5xl'} 
             ${isRed ? 'text-red-600' : isGreen ? 'text-green-700' : 'text-gray-800'} 
             ${className}`}>
            <span className="leading-none drop-shadow-sm">{tile.symbol}</span>
        </div>
    );
};

const PlayerAvatar = ({ player, isTurn, bubble, isSelf }) => {
    return (
        <div className={`relative flex flex-col items-center justify-center p-2 rounded-xl transition-all ${isTurn ? 'bg-yellow-500/20 ring-2 ring-yellow-400' : 'bg-black/20'}`}>
            <div className={`text-4xl sm:text-5xl drop-shadow-lg ${isTurn ? 'animate-bounce' : ''}`}>{player.avatar}</div>
            {bubble && (
                <div className="absolute -top-10 left-1/2 -translate-x-1/2 bg-white text-gray-900 font-bold text-xs px-3 py-1.5 rounded-xl shadow-xl whitespace-nowrap z-50 animate-pulse border-2 border-gray-200">
                    {bubble}
                    <div className="absolute -bottom-1.5 left-1/2 -translate-x-1/2 w-3 h-3 bg-white rotate-45 border-b-2 border-r-2 border-gray-200"></div>
                </div>
            )}
            <div className={`text-xs sm:text-sm font-bold mt-1 ${isSelf ? 'text-white' : player.style}`}>{player.name}</div>
            {!isSelf && (
                <div className="flex items-center gap-1 mt-1 text-[10px] text-white/70">
                    ğŸ€« x {player.hand.length}
                </div>
            )}
        </div>
    );
};

// ==========================================
// ä¸»éŠæˆ²å…ƒä»¶
// ==========================================

export default function App() {
    const [gameState, setGameState] = useState('menu');
    const [deck, setDeck] = useState([]);
    const [players, setPlayers] = useState([]);
    const [turn, setTurn] = useState(0);
    const [dealer, setDealer] = useState(0);
    const [selectedTileId, setSelectedTileId] = useState(null);
    const [messages, setMessages] = useState([]);
    const [bubbles, setBubbles] = useState({});
    const [interruption, setInterruption] = useState(null);
    const [winner, setWinner] = useState(null);
    const [toast, setToast] = useState('');

    useEffect(() => {
        registerServiceWorker();
    }, []);

    const showToast = useCallback((msg) => { 
        setToast(msg); 
        setTimeout(() => setToast(''), 2000); 
    }, []);

    const addMessage = useCallback((msg) => {
        setMessages(prev => [...prev.slice(-4), msg]);
    }, []);

    const showBubble = (pIndex, text) => {
        setBubbles(prev => ({ ...prev, [pIndex]: text }));
        setTimeout(() => setBubbles(prev => ({ ...prev, [pIndex]: null })), 3000);
    };

    const playQuote = (pIndex, type) => {
        if (pIndex === 0) return;
        const char = CHARACTERS[pIndex - 1];
        const quotes = char.quotes[type];
        if (quotes && Math.random() > 0.4) {
            showBubble(pIndex, quotes[Math.floor(Math.random() * quotes.length)]);
        }
    };

    const initGame = () => {
        const newDeck = generateDeck();
        let newPlayers = [
            { id: 0, name: 'ä½  (ç©å®¶)', avatar: 'ğŸ§‘ğŸ»', style: 'text-white', hand: [], discards: [], melds: [] },
            ...CHARACTERS.slice(0, 3).sort(() => Math.random() - 0.5).map((c, i) => ({ 
                id: i + 1, name: c.name, avatar: c.avatar, style: c.style, hand: [], discards: [], melds: [], quotes: c.quotes 
            }))
        ];
        let currentDealer = Math.floor(Math.random() * 4);
        for (let i = 0; i < 4; i++) {
            let numCards = i === currentDealer ? 17 : 16;
            newPlayers[i].hand = sortHand(newDeck.splice(0, numCards));
        }
        setDeck(newDeck);
        setPlayers(newPlayers);
        setDealer(currentDealer);
        setTurn(currentDealer);
        setWinner(null);
        setInterruption(null);
        setSelectedTileId(null);
        setMessages([`éŠæˆ²é–‹å§‹ï¼${newPlayers[currentDealer].name} æ˜¯èŠå®¶ã€‚`]);
        setGameState('playing');
        setBubbles({});
    };

    const declareWin = useCallback((winnerIndex, isSelfDraw, loserIndex = -1) => {
        setWinner(winnerIndex);
        setGameState('gameover');
        if (winnerIndex === 0) {
            playQuote(1, 'lose'); playQuote(2, 'lose'); playQuote(3, 'lose');
            addMessage(`ğŸ‰ æ­å–œï¼ä½ ${isSelfDraw ? 'è‡ªæ‘¸' : 'èƒ¡'}å•¦ï¼`);
        } else {
            playQuote(winnerIndex, 'win');
            addMessage(`ğŸ˜¢ ${players[winnerIndex].name} ${isSelfDraw ? 'è‡ªæ‘¸' : 'èƒ¡'}äº†ï¼`);
        }
    }, [players, addMessage]);

    const proceedToNextTurn = useCallback((nextTurnIndex) => {
        if (deck.length === 0) {
            addMessage("æµå±€ï¼ç‰Œå †å·²æ‘¸å®Œã€‚");
            setGameState('gameover');
            return;
        }
        let newDeck = [...deck];
        let newPlayers = [...players];
        const drawnTile = newDeck.shift();
        newPlayers[nextTurnIndex].hand.push(drawnTile);
        newPlayers[nextTurnIndex].hand = sortHand(newPlayers[nextTurnIndex].hand);
        setDeck(newDeck);
        setPlayers(newPlayers);
        setTurn(nextTurnIndex);
        if (nextTurnIndex !== 0) {
            playQuote(nextTurnIndex, 'draw');
        } else {
            addMessage(`è¼ªåˆ°ä½ äº†ï¼Œæ‘¸åˆ°äº† ${drawnTile.symbol}`);
            if (checkHu(newPlayers[0].hand)) showToast("ğŸ”¥ ä½ å¯ä»¥è‡ªæ‘¸å•¦ï¼ ğŸ”¥");
        }
    }, [deck, players, addMessage, showToast]);

    const checkPlayerInterruption = useCallback((tile, fromPlayer) => {
        let p0Hand = players[0].hand;
        let possibleActions = [];
        if (checkHu([...p0Hand, tile])) possibleActions.push('hu');
        const sameTiles = p0Hand.filter(t => t.id === tile.id);
        if (sameTiles.length >= 2) possibleActions.push('pong');

        if (possibleActions.length > 0) {
            setInterruption({ tile, fromPlayer, actions: possibleActions });
        } else {
            proceedToNextTurn((fromPlayer + 1) % 4);
        }
    }, [players, proceedToNextTurn]);

    const executeDiscard = useCallback((pIndex, tile) => {
        let newPlayers = [...players];
        newPlayers[pIndex].hand = newPlayers[pIndex].hand.filter(t => t.uniqueId !== tile.uniqueId);
        newPlayers[pIndex].hand = sortHand(newPlayers[pIndex].hand);
        newPlayers[pIndex].discards.push(tile);
        setPlayers(newPlayers);
        setSelectedTileId(null);
        addMessage(`${newPlayers[pIndex].name} æ‰“å‡ºäº† ${tile.symbol}`);
        if (pIndex !== 0) playQuote(pIndex, 'discard');

        if (pIndex !== 0) {
            checkPlayerInterruption(tile, pIndex);
        } else {
            proceedToNextTurn((pIndex + 1) % 4);
        }
    }, [players, addMessage, checkPlayerInterruption, proceedToNextTurn]);

    const handleDiscard = () => {
        if (turn !== 0 || interruption || winner !== null) return;
        if (!selectedTileId) return showToast("è«‹å…ˆé¸æ“‡ä¸€å¼µç‰Œï¼");
        if (players[0].hand.length % 3 !== 2) return showToast("é‚„æ²’è¼ªåˆ°ä½ æ‘¸ç‰Œï¼");
        const tileIndex = players[0].hand.findIndex(t => t.uniqueId === selectedTileId);
        const discardedTile = players[0].hand[tileIndex];
        executeDiscard(0, discardedTile);
    };

    useEffect(() => {
        if (gameState !== 'playing' || winner !== null || interruption) return;
        let timer;
        if (turn !== 0) {
            timer = setTimeout(() => {
                let aiHand = players[turn].hand;
                if (checkHu(aiHand)) {
                    declareWin(turn, true);
                    return;
                }
                let discardTile = aiHand[Math.floor(Math.random() * aiHand.length)];
                const counts = {};
                aiHand.forEach(t => counts[t.id] = (counts[t.id] || 0) + 1);
                const singles = aiHand.filter(t => counts[t.id] === 1 && (t.id.startsWith('F') || t.id.startsWith('J')));
                if (singles.length > 0) discardTile = singles[0];
                executeDiscard(turn, discardTile);
            }, 1500);
        }
        return () => clearTimeout(timer);
    }, [turn, gameState, winner, interruption, players, declareWin, executeDiscard]);

    const handleInterruption = (action) => {
        const { tile, fromPlayer } = interruption;
        let newPlayers = [...players];
        if (action === 'pass') {
            setInterruption(null);
            proceedToNextTurn((fromPlayer + 1) % 4);
            return;
        }
        if (action === 'hu') {
            newPlayers[0].hand.push(tile);
            newPlayers[fromPlayer].discards.pop();
            setPlayers(newPlayers);
            setInterruption(null);
            declareWin(0, false, fromPlayer);
            return;
        }
        if (action === 'pong') {
            const sameTiles = newPlayers[0].hand.filter(t => t.id === tile.id);
            const keepTiles = newPlayers[0].hand.filter(t => t.id !== tile.id);
            newPlayers[0].hand = keepTiles;
            newPlayers[fromPlayer].discards.pop();
            newPlayers[0].melds.push({ type: 'pong', tiles: [sameTiles[0], sameTiles[1], tile] });
            setPlayers(newPlayers);
            setInterruption(null);
            setTurn(0);
            addMessage(`ä½ ç¢°äº† ${tile.symbol}ï¼è«‹æ‰“å‡ºä¸€å¼µç‰Œã€‚`);
        }
    };

    const handleSelfHu = () => {
        if (turn !== 0 || players[0].hand.length % 3 !== 2) return;
        if (checkHu(players[0].hand)) {
            declareWin(0, true);
        } else {
            showToast("ç‰Œå‹ä¸ç¬¦åˆèƒ¡ç‰Œæ¢ä»¶å–”ï¼");
        }
    };

    if (gameState === 'menu') {
        return (
            <div className="flex flex-col items-center justify-center h-screen w-screen bg-green-900 text-white p-4 overflow-hidden relative font-sans">
                <div className="absolute inset-0 opacity-10 flex items-center justify-center text-[20rem] pointer-events-none">ğŸ€„</div>
                <h1 className="text-5xl sm:text-7xl font-extrabold mb-4 tracking-widest text-transparent bg-clip-text bg-gradient-to-b from-yellow-200 to-yellow-600 drop-shadow-[0_5px_5px_rgba(0,0,0,0.8)]">
                    æ–°æ˜æ˜Ÿä¸‰ç¼ºä¸€
                </h1>
                <p className="text-xl sm:text-2xl font-bold mb-12 text-yellow-400 drop-shadow-md">âœ¨ æ­£å®—å°ç£ 16 å¼µéº»å°‡ âœ¨</p>
                <div className="grid grid-cols-4 gap-4 mb-12">
                    {CHARACTERS.map((c, i) => (
                        <div key={i} className="flex flex-col items-center bg-black/40 p-4 rounded-2xl border border-white/20 shadow-xl">
                            <span className="text-5xl mb-2">{c.avatar}</span>
                            <span className={`font-bold ${c.style}`}>{c.name}</span>
                        </div>
                    ))}
                </div>
                <button onClick={initGame} className="px-12 py-4 bg-gradient-to-r from-yellow-500 to-yellow-600 text-red-900 rounded-full text-3xl font-black shadow-[0_8px_0_#9a3412] active:shadow-[0_0px_0_#9a3412] active:translate-y-2 transition-all hover:brightness-110">
                    æ‘¸å…«åœˆå»ï¼
                </button>
            </div>
        );
    }

    return (
        <div className="w-full h-screen bg-[#1a472a] relative overflow-hidden flex flex-col font-sans select-none touch-none">
            <div className="absolute inset-0 bg-[radial-gradient(circle_at_center,_#205b36_0%,_#12321d_100%)] opacity-90 pointer-events-none"></div>
            
            <div className="absolute top-4 left-4 bg-black/60 p-3 rounded-xl text-white text-xs sm:text-sm z-30 shadow-lg border border-green-800 backdrop-blur-sm">
                <div className="font-bold text-yellow-400 mb-2 border-b border-white/20 pb-1 flex justify-between">
                    <span>å‰©é¤˜ï¼š{deck.length}</span>
                </div>
                {players.map((p, i) => (
                    <div key={i} className={`flex items-center justify-between w-32 mb-1 ${i === dealer ? 'text-yellow-300' : 'text-gray-300'}`}>
                        <span>{i === dealer ? 'èŠ ' : ''}{p.name}</span>
                        <span className="text-[10px] opacity-70 border border-current px-1 rounded bg-black/50">ğŸ€« {p.hand.length}</span>
                    </div>
                ))}
            </div>

            <div className="absolute top-1/4 left-4 w-48 text-xs bg-black/30 p-2 rounded-lg text-white/80 max-h-32 overflow-hidden pointer-events-none z-20 hidden md:block border border-white/10">
                {messages.map((m, i) => <div key={i} className="mb-1">{m}</div>)}
            </div>

            {toast && (
                <div className="absolute top-1/3 left-1/2 -translate-x-1/2 bg-red-600/90 backdrop-blur-sm text-white px-8 py-3 rounded-full shadow-2xl z-[80] animate-bounce text-lg font-bold border-2 border-yellow-400">
                    {toast}
                </div>
            )}

            <div className="absolute top-4 left-1/2 -translate-x-1/2 flex flex-col items-center z-20">
                <PlayerAvatar player={players[2]} isTurn={turn === 2} bubble={bubbles[2]} />
                <div className="flex mt-2">
                    {players[2].discards.slice(-8).map((t, i) => <MahjongTile key={i} tile={t} isDiscard className="-ml-1" />)}
                </div>
            </div>

            <div className="absolute top-1/2 -translate-y-1/2 left-4 flex flex-row items-center z-20">
                <PlayerAvatar player={players[1]} isTurn={turn === 1} bubble={bubbles[1]} />
                <div className="flex flex-col ml-4">
                    {players[1].discards.slice(-6).map((t, i) => <MahjongTile key={i} tile={t} isDiscard className="-mt-2" />)}
                </div>
            </div>

            <div className="absolute top-1/2 -translate-y-1/2 right-4 flex flex-row-reverse items-center z-20">
                <PlayerAvatar player={players[3]} isTurn={turn === 3} bubble={bubbles[3]} />
                <div className="flex flex-col mr-4">
                    {players[3].discards.slice(-6).map((t, i) => <MahjongTile key={i} tile={t} isDiscard className="-mt-2" />)}
                </div>
            </div>

            <div className="absolute top-[55%] left-1/2 -translate-x-1/2 -translate-y-1/2 w-full max-w-lg z-10 flex flex-wrap justify-center gap-1 opacity-80 pointer-events-none px-12">
                 {players[0].discards.map((t, i) => <MahjongTile key={i} tile={t} isDiscard className="shadow-none" />)}
            </div>

            {interruption && (
                <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-50 bg-black/80 backdrop-blur-md p-6 rounded-2xl border-2 border-yellow-500 shadow-[0_0_30px_rgba(234,179,8,0.5)] flex flex-col items-center animate-pulse">
                    <p className="text-white mb-4 text-lg font-bold">{players[interruption.fromPlayer].name} å‡ºç‰Œï¼š</p>
                    <MahjongTile tile={interruption.tile} className="mb-6 scale-125" />
                    <div className="flex gap-4">
                        {interruption.actions.includes('hu') && (
                            <button onClick={() => handleInterruption('hu')} className="px-6 py-2 bg-red-600 text-white font-bold rounded shadow-lg hover:bg-red-500 text-xl">èƒ¡ï¼</button>
                        )}
                        {interruption.actions.includes('pong') && (
                            <button onClick={() => handleInterruption('pong')} className="px-6 py-2 bg-blue-600 text-white font-bold rounded shadow-lg hover:bg-blue-500 text-xl">ç¢°</button>
                        )}
                        <button onClick={() => handleInterruption('pass')} className="px-6 py-2 bg-gray-500 text-white font-bold rounded shadow-lg hover:bg-gray-400 text-xl">é</button>
                    </div>
                </div>
            )}

            <div className={`absolute bottom-0 left-0 w-full flex flex-col items-center pb-6 pt-10 transition-colors z-40 ${turn === 0 ? 'bg-gradient-to-t from-yellow-500/20 to-transparent' : ''}`}>
                <div className="flex items-center justify-between w-full px-4 max-w-4xl mx-auto mb-4 h-12">
                    <div className="flex items-center gap-4">
                        <PlayerAvatar player={players[0]} isTurn={turn === 0} isSelf />
                        {turn === 0 && !interruption && winner === null && (
                            <div className="flex gap-3">
                                <button onClick={handleDiscard} className={`px-6 py-2.5 rounded-full font-bold text-sm sm:text-base shadow-lg transition-transform ${selectedTileId ? 'bg-blue-600 text-white active:scale-95' : 'bg-gray-500 text-gray-300 cursor-not-allowed opacity-50'}`}>
                                    æ‰“ç‰Œ
                                </button>
                                {players[0].hand.length % 3 === 2 && (
                                    <button onClick={handleSelfHu} className="px-6 py-2.5 bg-red-600 text-white rounded-full shadow-[0_0_15px_rgba(220,38,38,0.8)] font-bold text-sm sm:text-base animate-pulse">
                                        è‡ªæ‘¸ï¼
                                    </button>
                                )}
                            </div>
                        )}
                    </div>
                </div>

                <div className="relative w-full max-w-5xl mx-auto flex items-end justify-center px-2 pb-2 h-24">
                    {players[0].melds.length > 0 && (
                        <div className="flex gap-2 mr-6 bg-black/30 p-2 rounded-xl">
                            {players[0].melds.map((meld, idx) => (
                                <div key={idx} className="flex">
                                    {meld.tiles.map((t, i) => <MahjongTile key={i} tile={t} isDiscard className="-ml-1 border-yellow-600" />)}
                                </div>
                            ))}
                        </div>
                    )}
                    <div className="flex items-end justify-center bg-black/20 p-2 rounded-2xl border-b-4 border-green-900 shadow-2xl overflow-x-auto max-w-full">
                        {players[0].hand.map((tile, idx) => {
                            const isDrawnTile = (idx === players[0].hand.length - 1) && (players[0].hand.length % 3 === 2);
                            return (
                                <div key={tile.uniqueId} className={`transition-all duration-200 ${isDrawnTile ? 'ml-4 sm:ml-6' : '-ml-1 sm:-ml-2'}`}>
                                    <MahjongTile 
                                        tile={tile} 
                                        isSelected={selectedTileId === tile.uniqueId} 
                                        onClick={() => turn === 0 && !interruption ? setSelectedTileId(selectedTileId === tile.uniqueId ? null : tile.uniqueId) : null} 
                                    />
                                </div>
                            )
                        })}
                    </div>
                </div>
            </div>

            {gameState === 'gameover' && (
                <div className="absolute inset-0 bg-black/90 backdrop-blur-sm z-[100] flex flex-col items-center justify-center p-4">
                    <h1 className={`text-5xl sm:text-6xl font-extrabold mb-8 animate-bounce text-center ${winner === 0 ? 'text-yellow-400' : 'text-gray-300'}`}>
                        {winner === 0 ? 'ğŸ† ä½ è´å•¦ï¼èƒ¡ç‰Œï¼' : winner !== null ? `ğŸ˜¢ ${players[winner].name} èƒ¡ç‰Œï¼` : 'ğŸ¤ æµå±€ï¼'}
                    </h1>
                    <div className="flex space-x-6">
                        <button onClick={initGame} className="px-10 py-4 bg-gradient-to-r from-green-500 to-green-600 text-white rounded-full text-2xl font-bold shadow-[0_6px_0_#166534] active:translate-y-2 active:shadow-none transition-all">
                            å†ä¾†ä¸€å±€
                        </button>
                        <button onClick={() => setGameState('menu')} className="px-8 py-4 bg-gray-700 text-white rounded-full text-xl font-bold shadow-[0_6px_0_#374151] active:translate-y-2 active:shadow-none transition-all">
                            å›é¦–é 
                        </button>
                    </div>
                </div>
            )}

            <style>{`
                body { margin: 0; overflow: hidden; background: #1a472a; overscroll-behavior-y: contain; }
                * { -webkit-tap-highlight-color: transparent; }
            `}</style>
        </div>
    );
}

